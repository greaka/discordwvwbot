package main

import (
	"context"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"strings"

	"github.com/bwmarrin/discordgo"
	"github.com/gomodule/redigo/redis"
	"github.com/greaka/discordwvwbot/loglevels"
	"github.com/greaka/discordwvwbot/webhooklogger"

	"golang.org/x/oauth2"
)

const discordAPIURL string = "https://discordapp.com/api"
const gw2APIURL string = "https://api.guildwars2.com/v2"

// tokenInfo is the struct to the gw2 api endpoint /v2/tokeninfo
type tokenInfo struct {
	ID          string   `json:"id"`
	Name        string   `json:"name"`
	Permissions []string `json:"permissions"`
}

// config is the struct for the bot internal config file
var config struct {
	// CertificatePath holds a string to the path of a full cert chain in pem format
	CertificatePath string `json:"certificatePath"`

	// PrivateKeyPath holds a string to the path of the corresponding private key to the cert in pem format
	PrivateKeyPath string `json:"privateKeyPath"`

	// BotToken holds the bot token generated by discord to authenticate the bot part
	BotToken string `json:"botToken"`

	// DiscordClientID holds the discord client id generated by discord to identify the oauth part
	DiscordClientID string `json:"discordClientId"`

	// DiscordAuthSecret holds the discord authentication secret generated by discord to authenticate against oauth
	DiscordAuthSecret string `json:"discordOAuthSecret"`

	// HostURL holds the domain name (DNS)
	HostURL string `json:"domain"`

	// HTMLPath holds the path to the mainpage to serve
	HTMLPath string `json:"html"`

	// RedisConnectionString holds the redis database connection string to authenticate with
	RedisConnectionString string `json:"redis"`

	// RedirectURL holds the relative url where oauth requests get redirected to.
	// This has to be identical to your settings at the discord bot settings page.
	RedirectURL string `json:"oAuthRedirect"`

	// WebhookIDInfo writes logs to the given webhook if set up
	// WebhookIDInfo is optional
	WebhookIDInfo string `json:"webhookIdInfo"`

	// WebhookTokenInfo is the auth token for the webhook
	// WebhookTokenInfo is optional
	WebhookTokenInfo string `json:"webhookTokenInfo"`

	// WebhookIDWarning writes logs to the given webhook if set up
	// WebhookIDWarning is optional
	WebhookIDWarning string `json:"webhookIdWarning"`

	// WebhookTokenWarning is the auth token for the webhook
	// WebhookTokenWarning is optional
	WebhookTokenWarning string `json:"webhookTokenWarning"`

	// WebhookIDError writes logs to the given webhook if set up
	// WebhookIDError is optional
	WebhookIDError string `json:"webhookIdError"`

	// WebhookTokenError is the auth token for the webhook
	// WebhookTokenError is optional
	WebhookTokenError string `json:"webhookTokenError"`
}

var (
	// oauthConfig saves the oauth config for the discord login
	oauthConfig *oauth2.Config

	// mainpage is the page that gets served at / in string format
	mainpage string

	// redisConn holds the connection to the redis database
	redisConn redis.Conn
)

// redirectToTLS is the handler function for http calls to get redirected to https
func redirectToTLS(w http.ResponseWriter, r *http.Request) {
	http.Redirect(w, r, "https://"+r.Host+r.RequestURI, http.StatusMovedPermanently)
}

// handleRootRequest serves the mainpage
func handleRootRequest(w http.ResponseWriter, r *http.Request) {
	addHeaders(w, r)
	if _, err := fmt.Fprintf(w, mainpage); err != nil {
		loglevels.Errorf("Error handling root request: %v\n", err)
	}
}

// handleAuthCallback is listening to returning oauth requests to discord
// nolint: gocyclo
func handleAuthCallback(w http.ResponseWriter, r *http.Request) {
	addHeaders(w, r)
	state := r.FormValue("state")
	// request oauth access with the issue data sent by discord
	token, err := oauthConfig.Exchange(context.Background(), r.FormValue("code"))
	// err will also be not nil when the user presses Cancel at the oauth request
	if err != nil {
		loglevels.Errorf("Error getting token: %v\n", err)
		if _, erro := fmt.Fprint(w, "Error getting discord authorization token."); erro != nil {
			loglevels.Errorf("Error writing to Responsewriter: %v and %v\n", err, erro)
		}
		return
	}

	// get discord id
	client := &http.Client{}
	req, err := http.NewRequest("GET", discordAPIURL+"/users/@me", nil)
	if err != nil {
		loglevels.Errorf("Error creating a new request: %v\n", err)
		if _, erro := fmt.Fprint(w, "Internal error, please try again or contact me."); erro != nil {
			loglevels.Errorf("Error writing to Responsewriter: %v and %v\n", err, erro)
		}
		return
	}
	token.SetAuthHeader(req)
	res, err := client.Do(req)
	if err != nil {
		loglevels.Errorf("Error getting discord id: %v\n", err)
		if _, erro := fmt.Fprint(w, "Error getting discord id. Please contact me."); erro != nil {
			loglevels.Errorf("Error writing to Responsewriter: %v and %v\n", err, erro)
		}
		return
	}
	defer func() {
		if err = res.Body.Close(); err != nil {
			loglevels.Errorf("Error closing response body: %v\n", err)
		}
	}()

	// parse user json to discordgo.User
	jsonParser := json.NewDecoder(res.Body)
	var user discordgo.User
	err = jsonParser.Decode(&user)
	if err != nil {
		loglevels.Errorf("Error parsing json to discordgo.User: %v\n", err)
		if _, erro := fmt.Fprint(w, "Internal error, please try again or contact me."); erro != nil {
			loglevels.Errorf("Error writing to Responsewriter: %v and %v\n", err, erro)
		}
		return
	}

	switch state {

	// delete everything we know about this user
	case "deletemydata":
		_, err = redisConn.Do("DEL", user.ID)
		if err != nil {
			loglevels.Errorf("Error deleting key from redis: %v\n", err)
			if _, erro := fmt.Fprint(w, "Internal error, please try again or contact me."); erro != nil {
				loglevels.Errorf("Error writing to Responsewriter: %v and %v\n", err, erro)
			}
			return
		}

	// sync the user on all discord servers
	case "syncnow":
		updateUserChannel <- user.ID

	// state holds api key, save api key and update user
	default:
		// SADD will ignore the request if the apikey is already saved from this user
		_, err = redisConn.Do("SADD", user.ID, state)
		if err != nil {
			loglevels.Errorf("Error saving key to redis: %v\n", err)
			if _, erro := fmt.Fprint(w, "Internal error, please try again or contact me."); erro != nil {
				loglevels.Errorf("Error writing to Responsewriter: %v and %v\n", err, erro)
			}
			return
		}
		loglevels.Infof("New user: %v", user.ID)
		updateUserChannel <- user.ID
	}

	if _, err = fmt.Fprint(w, "Success"); err != nil {
		loglevels.Errorf("Error writing to Responsewriter: %v\n", err)
	}
}

// handleAuthRequest forges the oauth request to discord and packs data for the callback
// nolint: gocyclo
func handleAuthRequest(w http.ResponseWriter, r *http.Request) {
	addHeaders(w, r)
	key := r.FormValue("key")
	// filter if request contains special keywords
	switch key {
	case "deletemydata":
	case "syncnow":
	default:
		// check if api key is valid
		res, err := http.Get(gw2APIURL + "/tokeninfo?access_token=" + key)
		if err != nil {
			loglevels.Errorf("Error quering tokeninfo: %v\n", err)
			if _, erro := fmt.Fprint(w, "Internal error, please try again or contact me."); erro != nil {
				loglevels.Errorf("Error writing to Responsewriter: %v and %v\n", err, erro)
			}
			return
		}
		defer func() {
			if err = res.Body.Close(); err != nil {
				loglevels.Errorf("Error closing response body: %v\n", err)
			}
		}()
		// parse tokeninfo
		jsonParser := json.NewDecoder(res.Body)
		var token tokenInfo
		err = jsonParser.Decode(&token)
		if err != nil {
			loglevels.Errorf("Error parsing json to tokeninfo: %v\n", err)
			if _, erro := fmt.Fprint(w, "Internal error, please try again or contact me."); erro != nil {
				loglevels.Errorf("Error writing to Responsewriter: %v and %v\n", err, erro)
			}
			return
		}
		// check if api key contains wvwbot
		nameInLower := strings.ToLower(token.Name)
		if !strings.Contains(nameInLower, "wvw") || !strings.Contains(nameInLower, "bot") {
			if _, erro := fmt.Fprintf(w, "This api key is not valid. Make sure your key name contains 'wvwbot'. This api key is named %v", token.Name); erro != nil {
				loglevels.Errorf("Error writing to Responsewriter: %v and %v\n", err, erro)
			}
			return
		}
	}

	// redirect to discord login
	// we can use the key as state here because we are not vulnerable to csrf (change my mind)
	http.Redirect(w, r, oauthConfig.AuthCodeURL(key), http.StatusTemporaryRedirect)
}

// handleInvite responds with a discord URL to invite this bot to a discord server
func handleInvite(w http.ResponseWriter, r *http.Request) {
	addHeaders(w, r)
	http.Redirect(w, r, "https://discordapp.com/oauth2/authorize?client_id="+config.DiscordClientID+"&scope=bot&permissions=402653184", http.StatusPermanentRedirect)
}

// addHeaders adds the standard headers to the http.ResponseWriter
func addHeaders(w http.ResponseWriter, r *http.Request) {
	w.Header().Add("Strict-Transport-Security", "max-age=63072000; includeSubDomains")
}

// main is the entry point and fires up everything
// nolint: gocyclo
func main() {
	// open log file to write to it
	f, err := os.OpenFile("botlog", os.O_RDWR|os.O_CREATE|os.O_APPEND, 0600)
	if err != nil {
		log.Fatalf("error opening log file: %v", err)
	}
	defer func() {
		if err = f.Close(); err != nil {
			loglevels.Errorf("Error closing log file: %v\n", err)
		}
	}()

	// set log file
	loglevels.SetWriter(loglevels.LevelInfo, f)
	loglevels.SetWriter(loglevels.LevelWarning, f)
	loglevels.SetWriter(loglevels.LevelError, f)
	loglevels.Info("Starting up...")

	// load config
	conf, err := os.Open("config.json")
	if err != nil {
		loglevels.Errorf("Error opening config file: %v\n", err)
		os.Exit(1)
	}
	defer func() {
		if err = conf.Close(); err != nil {
			loglevels.Errorf("Error closing config file: %v\n", err)
		}
	}()
	jsonParser := json.NewDecoder(conf)
	if err = jsonParser.Decode(&config); err != nil {
		loglevels.Errorf("Error parsing config file: %v\n", err)
		os.Exit(1)
	}

	// connect to the discord bot api
	dg, err = discordgo.New("Bot " + config.BotToken)
	if err != nil {
		loglevels.Errorf("Error connecting to discord: %v\n", err)
		os.Exit(1)
	}

	var webhookLoggerInfo webhooklogger.WebhookLogger
	if config.WebhookIDInfo != "" && config.WebhookTokenInfo != "" {
		webhookLoggerInfo = webhooklogger.WebhookLogger{}
		webhookLoggerInfo.SetOutput(dg, config.WebhookIDInfo, config.WebhookTokenInfo)
		w := io.MultiWriter(f, webhookLoggerInfo)
		loglevels.SetWriter(loglevels.LevelInfo, w)
	}

	var webhookLoggerWarning webhooklogger.WebhookLogger
	if config.WebhookIDWarning != "" && config.WebhookTokenWarning != "" {
		webhookLoggerWarning = webhooklogger.WebhookLogger{}
		webhookLoggerWarning.SetOutput(dg, config.WebhookIDWarning, config.WebhookTokenWarning)
		w := io.MultiWriter(f, webhookLoggerWarning)
		loglevels.SetWriter(loglevels.LevelWarning, w)
	}

	var webhookLoggerError webhooklogger.WebhookLogger
	if config.WebhookIDError != "" && config.WebhookTokenError != "" {
		webhookLoggerError = webhooklogger.WebhookLogger{}
		webhookLoggerError.SetOutput(dg, config.WebhookIDError, config.WebhookTokenError)
		w := io.MultiWriter(f, webhookLoggerError)
		loglevels.SetWriter(loglevels.LevelError, w)
	}

	// open redis connection
	red, err := redis.DialURL(config.RedisConnectionString)
	if err != nil {
		loglevels.Errorf("Error connecting to redis server: %v\n", err)
		os.Exit(1)
	}
	redisConn = red
	defer func() {
		if err = red.Close(); err != nil {
			loglevels.Errorf("Error closing redis connection: %v\n", err)
		}
	}()

	// starting up bot part
	go startBot()

	oauthConfig = &oauth2.Config{
		ClientID:     config.DiscordClientID,
		ClientSecret: config.DiscordAuthSecret,
		Endpoint: oauth2.Endpoint{
			AuthURL:  discordAPIURL + "/oauth2/authorize",
			TokenURL: discordAPIURL + "/oauth2/token",
		},
		RedirectURL: config.HostURL + config.RedirectURL,
		Scopes:      []string{"identify"},
	}

	// loading mainpage
	htmlFile, err := ioutil.ReadFile(config.HTMLPath)
	if err != nil {
		loglevels.Errorf("Error opening html file: %v\n", err)
		os.Exit(1)
	}
	mainpage = string(htmlFile)

	// starting http->https redirect
	go func() {
		loglevels.Info("starting up http redirect...")
		if err := http.ListenAndServe(":80", http.HandlerFunc(redirectToTLS)); err != nil {
			loglevels.Warningf("Error on http redirect, ListenAndServeError: %v\n", err)
		}
	}()

	// setting up https server
	mux := http.NewServeMux()

	mux.HandleFunc("/", handleRootRequest)
	mux.HandleFunc("/login", handleAuthRequest)
	mux.HandleFunc(config.RedirectURL, handleAuthCallback)
	mux.HandleFunc("/invite", handleInvite)
	cfg := &tls.Config{
		MinVersion:               tls.VersionTLS12,
		CurvePreferences:         []tls.CurveID{tls.CurveP521, tls.CurveP384, tls.CurveP256},
		PreferServerCipherSuites: true,
		CipherSuites: []uint16{
			tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
			tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
			tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
			tls.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
		},
	}
	srv := &http.Server{
		Addr:         ":443",
		Handler:      mux,
		TLSConfig:    cfg,
		TLSNextProto: make(map[string]func(*http.Server, *tls.Conn, http.Handler)),
	}

	loglevels.Info("starting up https listener...")
	loglevels.Error(srv.ListenAndServeTLS(config.CertificatePath, config.PrivateKeyPath))
	os.Exit(1)
}
